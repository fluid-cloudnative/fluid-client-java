/*
 * fluid
 * Python SDK for fluid
 *
 * OpenAPI spec version: v0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package com.github.fluid_cloudnative.fluid;

import com.google.gson.annotations.SerializedName;
import io.kubernetes.client.openapi.models.V1Toleration;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * DatasetSpec defines the desired state of Dataset
 */
@ApiModel(description = "DatasetSpec defines the desired state of Dataset")
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2021-05-14T16:48:53.494+08:00")
public class DatasetSpec {
  @SerializedName("accessModes")
  private List<String> accessModes = null;

  @SerializedName("dataRestoreLocation")
  private DataRestoreLocation dataRestoreLocation = null;

  @SerializedName("mounts")
  private List<Mount> mounts = null;

  @SerializedName("nodeAffinity")
  private CacheableNodeAffinity nodeAffinity = null;

  @SerializedName("owner")
  private User owner = null;

  @SerializedName("placement")
  private String placement = null;

  @SerializedName("runtimes")
  private List<Runtime> runtimes = null;

  @SerializedName("tolerations")
  private List<V1Toleration> tolerations = null;

  public DatasetSpec accessModes(List<String> accessModes) {
    this.accessModes = accessModes;
    return this;
  }

  public DatasetSpec addAccessModesItem(String accessModesItem) {
    if (this.accessModes == null) {
      this.accessModes = new ArrayList<String>();
    }
    this.accessModes.add(accessModesItem);
    return this;
  }

   /**
   * AccessModes contains all ways the volume backing the PVC can be mounted
   * @return accessModes
  **/
  @ApiModelProperty(value = "AccessModes contains all ways the volume backing the PVC can be mounted")
  public List<String> getAccessModes() {
    return accessModes;
  }

  public void setAccessModes(List<String> accessModes) {
    this.accessModes = accessModes;
  }

  public DatasetSpec dataRestoreLocation(DataRestoreLocation dataRestoreLocation) {
    this.dataRestoreLocation = dataRestoreLocation;
    return this;
  }

   /**
   * DataRestoreLocation is the location to load data of dataset  been backuped
   * @return dataRestoreLocation
  **/
  @ApiModelProperty(value = "DataRestoreLocation is the location to load data of dataset  been backuped")
  public DataRestoreLocation getDataRestoreLocation() {
    return dataRestoreLocation;
  }

  public void setDataRestoreLocation(DataRestoreLocation dataRestoreLocation) {
    this.dataRestoreLocation = dataRestoreLocation;
  }

  public DatasetSpec mounts(List<Mount> mounts) {
    this.mounts = mounts;
    return this;
  }

  public DatasetSpec addMountsItem(Mount mountsItem) {
    if (this.mounts == null) {
      this.mounts = new ArrayList<Mount>();
    }
    this.mounts.add(mountsItem);
    return this;
  }

   /**
   * Mount Points to be mounted on Alluxio.
   * @return mounts
  **/
  @ApiModelProperty(value = "Mount Points to be mounted on Alluxio.")
  public List<Mount> getMounts() {
    return mounts;
  }

  public void setMounts(List<Mount> mounts) {
    this.mounts = mounts;
  }

  public DatasetSpec nodeAffinity(CacheableNodeAffinity nodeAffinity) {
    this.nodeAffinity = nodeAffinity;
    return this;
  }

   /**
   * NodeAffinity defines constraints that limit what nodes this dataset can be cached to. This field influences the scheduling of pods that use the cached dataset.
   * @return nodeAffinity
  **/
  @ApiModelProperty(value = "NodeAffinity defines constraints that limit what nodes this dataset can be cached to. This field influences the scheduling of pods that use the cached dataset.")
  public CacheableNodeAffinity getNodeAffinity() {
    return nodeAffinity;
  }

  public void setNodeAffinity(CacheableNodeAffinity nodeAffinity) {
    this.nodeAffinity = nodeAffinity;
  }

  public DatasetSpec owner(User owner) {
    this.owner = owner;
    return this;
  }

   /**
   * The owner of the dataset
   * @return owner
  **/
  @ApiModelProperty(value = "The owner of the dataset")
  public User getOwner() {
    return owner;
  }

  public void setOwner(User owner) {
    this.owner = owner;
  }

  public DatasetSpec placement(String placement) {
    this.placement = placement;
    return this;
  }

   /**
   * Manage switch for opening Multiple datasets single node deployment or not
   * @return placement
  **/
  @ApiModelProperty(value = "Manage switch for opening Multiple datasets single node deployment or not")
  public String getPlacement() {
    return placement;
  }

  public void setPlacement(String placement) {
    this.placement = placement;
  }

  public DatasetSpec runtimes(List<Runtime> runtimes) {
    this.runtimes = runtimes;
    return this;
  }

  public DatasetSpec addRuntimesItem(Runtime runtimesItem) {
    if (this.runtimes == null) {
      this.runtimes = new ArrayList<Runtime>();
    }
    this.runtimes.add(runtimesItem);
    return this;
  }

   /**
   * Runtimes for supporting dataset (e.g. AlluxioRuntime)
   * @return runtimes
  **/
  @ApiModelProperty(value = "Runtimes for supporting dataset (e.g. AlluxioRuntime)")
  public List<Runtime> getRuntimes() {
    return runtimes;
  }

  public void setRuntimes(List<Runtime> runtimes) {
    this.runtimes = runtimes;
  }

  public DatasetSpec tolerations(List<V1Toleration> tolerations) {
    this.tolerations = tolerations;
    return this;
  }

  public DatasetSpec addTolerationsItem(V1Toleration tolerationsItem) {
    if (this.tolerations == null) {
      this.tolerations = new ArrayList<V1Toleration>();
    }
    this.tolerations.add(tolerationsItem);
    return this;
  }

   /**
   * If specified, the pod&#39;s tolerations.
   * @return tolerations
  **/
  @ApiModelProperty(value = "If specified, the pod's tolerations.")
  public List<V1Toleration> getTolerations() {
    return tolerations;
  }

  public void setTolerations(List<V1Toleration> tolerations) {
    this.tolerations = tolerations;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DatasetSpec datasetSpec = (DatasetSpec) o;
    return Objects.equals(this.accessModes, datasetSpec.accessModes) &&
        Objects.equals(this.dataRestoreLocation, datasetSpec.dataRestoreLocation) &&
        Objects.equals(this.mounts, datasetSpec.mounts) &&
        Objects.equals(this.nodeAffinity, datasetSpec.nodeAffinity) &&
        Objects.equals(this.owner, datasetSpec.owner) &&
        Objects.equals(this.placement, datasetSpec.placement) &&
        Objects.equals(this.runtimes, datasetSpec.runtimes) &&
        Objects.equals(this.tolerations, datasetSpec.tolerations);
  }

  @Override
  public int hashCode() {
    return Objects.hash(accessModes, dataRestoreLocation, mounts, nodeAffinity, owner, placement, runtimes, tolerations);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DatasetSpec {\n");
    
    sb.append("    accessModes: ").append(toIndentedString(accessModes)).append("\n");
    sb.append("    dataRestoreLocation: ").append(toIndentedString(dataRestoreLocation)).append("\n");
    sb.append("    mounts: ").append(toIndentedString(mounts)).append("\n");
    sb.append("    nodeAffinity: ").append(toIndentedString(nodeAffinity)).append("\n");
    sb.append("    owner: ").append(toIndentedString(owner)).append("\n");
    sb.append("    placement: ").append(toIndentedString(placement)).append("\n");
    sb.append("    runtimes: ").append(toIndentedString(runtimes)).append("\n");
    sb.append("    tolerations: ").append(toIndentedString(tolerations)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}


/*
 * fluid
 * client for fluid
 *
 * The version of the OpenAPI document: v0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import models.CleanCachePolicy;
import models.JindoCompTemplateSpec;
import models.JindoFuseSpec;
import models.PodMetadata;
import models.TieredStore;
import models.User;
import models.V1Volume;
import models.VersionSpec;

/**
 * JindoRuntimeSpec defines the desired state of JindoRuntime
 */
@ApiModel(description = "JindoRuntimeSpec defines the desired state of JindoRuntime")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-12-15T22:35:53.526622+08:00[Asia/Shanghai]")
public class JindoRuntimeSpec {
  public static final String SERIALIZED_NAME_CLEAN_CACHE_POLICY = "cleanCachePolicy";
  @SerializedName(SERIALIZED_NAME_CLEAN_CACHE_POLICY)
  private CleanCachePolicy cleanCachePolicy;

  public static final String SERIALIZED_NAME_FUSE = "fuse";
  @SerializedName(SERIALIZED_NAME_FUSE)
  private JindoFuseSpec fuse;

  public static final String SERIALIZED_NAME_HADOOP_CONFIG = "hadoopConfig";
  @SerializedName(SERIALIZED_NAME_HADOOP_CONFIG)
  private String hadoopConfig;

  public static final String SERIALIZED_NAME_JINDO_VERSION = "jindoVersion";
  @SerializedName(SERIALIZED_NAME_JINDO_VERSION)
  private VersionSpec jindoVersion;

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private Map<String, String> labels = null;

  public static final String SERIALIZED_NAME_LOG_CONFIG = "logConfig";
  @SerializedName(SERIALIZED_NAME_LOG_CONFIG)
  private Map<String, String> logConfig = null;

  public static final String SERIALIZED_NAME_MASTER = "master";
  @SerializedName(SERIALIZED_NAME_MASTER)
  private JindoCompTemplateSpec master;

  public static final String SERIALIZED_NAME_NETWORKMODE = "networkmode";
  @SerializedName(SERIALIZED_NAME_NETWORKMODE)
  private String networkmode;

  public static final String SERIALIZED_NAME_POD_METADATA = "podMetadata";
  @SerializedName(SERIALIZED_NAME_POD_METADATA)
  private PodMetadata podMetadata;

  public static final String SERIALIZED_NAME_PROPERTIES = "properties";
  @SerializedName(SERIALIZED_NAME_PROPERTIES)
  private Map<String, String> properties = null;

  public static final String SERIALIZED_NAME_REPLICAS = "replicas";
  @SerializedName(SERIALIZED_NAME_REPLICAS)
  private Integer replicas;

  public static final String SERIALIZED_NAME_RUN_AS = "runAs";
  @SerializedName(SERIALIZED_NAME_RUN_AS)
  private User runAs;

  public static final String SERIALIZED_NAME_SECRET = "secret";
  @SerializedName(SERIALIZED_NAME_SECRET)
  private String secret;

  public static final String SERIALIZED_NAME_TIEREDSTORE = "tieredstore";
  @SerializedName(SERIALIZED_NAME_TIEREDSTORE)
  private TieredStore tieredstore;

  public static final String SERIALIZED_NAME_USER = "user";
  @SerializedName(SERIALIZED_NAME_USER)
  private String user;

  public static final String SERIALIZED_NAME_VOLUMES = "volumes";
  @SerializedName(SERIALIZED_NAME_VOLUMES)
  private List<V1Volume> volumes = null;

  public static final String SERIALIZED_NAME_WORKER = "worker";
  @SerializedName(SERIALIZED_NAME_WORKER)
  private JindoCompTemplateSpec worker;


  public JindoRuntimeSpec cleanCachePolicy(CleanCachePolicy cleanCachePolicy) {
    
    this.cleanCachePolicy = cleanCachePolicy;
    return this;
  }

   /**
   * Get cleanCachePolicy
   * @return cleanCachePolicy
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public CleanCachePolicy getCleanCachePolicy() {
    return cleanCachePolicy;
  }


  public void setCleanCachePolicy(CleanCachePolicy cleanCachePolicy) {
    this.cleanCachePolicy = cleanCachePolicy;
  }


  public JindoRuntimeSpec fuse(JindoFuseSpec fuse) {
    
    this.fuse = fuse;
    return this;
  }

   /**
   * Get fuse
   * @return fuse
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public JindoFuseSpec getFuse() {
    return fuse;
  }


  public void setFuse(JindoFuseSpec fuse) {
    this.fuse = fuse;
  }


  public JindoRuntimeSpec hadoopConfig(String hadoopConfig) {
    
    this.hadoopConfig = hadoopConfig;
    return this;
  }

   /**
   * Name of the configMap used to support HDFS configurations when using HDFS as Jindo&#39;s UFS. The configMap must be in the same namespace with the JindoRuntime. The configMap should contain user-specific HDFS conf files in it. For now, only \&quot;hdfs-site.xml\&quot; and \&quot;core-site.xml\&quot; are supported. It must take the filename of the conf file as the key and content of the file as the value.
   * @return hadoopConfig
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Name of the configMap used to support HDFS configurations when using HDFS as Jindo's UFS. The configMap must be in the same namespace with the JindoRuntime. The configMap should contain user-specific HDFS conf files in it. For now, only \"hdfs-site.xml\" and \"core-site.xml\" are supported. It must take the filename of the conf file as the key and content of the file as the value.")

  public String getHadoopConfig() {
    return hadoopConfig;
  }


  public void setHadoopConfig(String hadoopConfig) {
    this.hadoopConfig = hadoopConfig;
  }


  public JindoRuntimeSpec jindoVersion(VersionSpec jindoVersion) {
    
    this.jindoVersion = jindoVersion;
    return this;
  }

   /**
   * Get jindoVersion
   * @return jindoVersion
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public VersionSpec getJindoVersion() {
    return jindoVersion;
  }


  public void setJindoVersion(VersionSpec jindoVersion) {
    this.jindoVersion = jindoVersion;
  }


  public JindoRuntimeSpec labels(Map<String, String> labels) {
    
    this.labels = labels;
    return this;
  }

  public JindoRuntimeSpec putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<String, String>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

   /**
   * Labels will be added on all the JindoFS pods. DEPRECATED: this is a deprecated field. Please use PodMetadata.Labels instead. Note: this field is set to be exclusive with PodMetadata.Labels
   * @return labels
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Labels will be added on all the JindoFS pods. DEPRECATED: this is a deprecated field. Please use PodMetadata.Labels instead. Note: this field is set to be exclusive with PodMetadata.Labels")

  public Map<String, String> getLabels() {
    return labels;
  }


  public void setLabels(Map<String, String> labels) {
    this.labels = labels;
  }


  public JindoRuntimeSpec logConfig(Map<String, String> logConfig) {
    
    this.logConfig = logConfig;
    return this;
  }

  public JindoRuntimeSpec putLogConfigItem(String key, String logConfigItem) {
    if (this.logConfig == null) {
      this.logConfig = new HashMap<String, String>();
    }
    this.logConfig.put(key, logConfigItem);
    return this;
  }

   /**
   * Get logConfig
   * @return logConfig
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public Map<String, String> getLogConfig() {
    return logConfig;
  }


  public void setLogConfig(Map<String, String> logConfig) {
    this.logConfig = logConfig;
  }


  public JindoRuntimeSpec master(JindoCompTemplateSpec master) {
    
    this.master = master;
    return this;
  }

   /**
   * Get master
   * @return master
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public JindoCompTemplateSpec getMaster() {
    return master;
  }


  public void setMaster(JindoCompTemplateSpec master) {
    this.master = master;
  }


  public JindoRuntimeSpec networkmode(String networkmode) {
    
    this.networkmode = networkmode;
    return this;
  }

   /**
   * Whether to use hostnetwork or not
   * @return networkmode
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Whether to use hostnetwork or not")

  public String getNetworkmode() {
    return networkmode;
  }


  public void setNetworkmode(String networkmode) {
    this.networkmode = networkmode;
  }


  public JindoRuntimeSpec podMetadata(PodMetadata podMetadata) {
    
    this.podMetadata = podMetadata;
    return this;
  }

   /**
   * Get podMetadata
   * @return podMetadata
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public PodMetadata getPodMetadata() {
    return podMetadata;
  }


  public void setPodMetadata(PodMetadata podMetadata) {
    this.podMetadata = podMetadata;
  }


  public JindoRuntimeSpec properties(Map<String, String> properties) {
    
    this.properties = properties;
    return this;
  }

  public JindoRuntimeSpec putPropertiesItem(String key, String propertiesItem) {
    if (this.properties == null) {
      this.properties = new HashMap<String, String>();
    }
    this.properties.put(key, propertiesItem);
    return this;
  }

   /**
   * Configurable properties for Jindo system. &lt;br&gt;
   * @return properties
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Configurable properties for Jindo system. <br>")

  public Map<String, String> getProperties() {
    return properties;
  }


  public void setProperties(Map<String, String> properties) {
    this.properties = properties;
  }


  public JindoRuntimeSpec replicas(Integer replicas) {
    
    this.replicas = replicas;
    return this;
  }

   /**
   * The replicas of the worker, need to be specified
   * @return replicas
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The replicas of the worker, need to be specified")

  public Integer getReplicas() {
    return replicas;
  }


  public void setReplicas(Integer replicas) {
    this.replicas = replicas;
  }


  public JindoRuntimeSpec runAs(User runAs) {
    
    this.runAs = runAs;
    return this;
  }

   /**
   * Get runAs
   * @return runAs
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public User getRunAs() {
    return runAs;
  }


  public void setRunAs(User runAs) {
    this.runAs = runAs;
  }


  public JindoRuntimeSpec secret(String secret) {
    
    this.secret = secret;
    return this;
  }

   /**
   * Get secret
   * @return secret
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public String getSecret() {
    return secret;
  }


  public void setSecret(String secret) {
    this.secret = secret;
  }


  public JindoRuntimeSpec tieredstore(TieredStore tieredstore) {
    
    this.tieredstore = tieredstore;
    return this;
  }

   /**
   * Get tieredstore
   * @return tieredstore
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public TieredStore getTieredstore() {
    return tieredstore;
  }


  public void setTieredstore(TieredStore tieredstore) {
    this.tieredstore = tieredstore;
  }


  public JindoRuntimeSpec user(String user) {
    
    this.user = user;
    return this;
  }

   /**
   * Get user
   * @return user
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public String getUser() {
    return user;
  }


  public void setUser(String user) {
    this.user = user;
  }


  public JindoRuntimeSpec volumes(List<V1Volume> volumes) {
    
    this.volumes = volumes;
    return this;
  }

  public JindoRuntimeSpec addVolumesItem(V1Volume volumesItem) {
    if (this.volumes == null) {
      this.volumes = new ArrayList<V1Volume>();
    }
    this.volumes.add(volumesItem);
    return this;
  }

   /**
   * Volumes is the list of Kubernetes volumes that can be mounted by the jindo runtime components and/or fuses.
   * @return volumes
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Volumes is the list of Kubernetes volumes that can be mounted by the jindo runtime components and/or fuses.")

  public List<V1Volume> getVolumes() {
    return volumes;
  }


  public void setVolumes(List<V1Volume> volumes) {
    this.volumes = volumes;
  }


  public JindoRuntimeSpec worker(JindoCompTemplateSpec worker) {
    
    this.worker = worker;
    return this;
  }

   /**
   * Get worker
   * @return worker
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public JindoCompTemplateSpec getWorker() {
    return worker;
  }


  public void setWorker(JindoCompTemplateSpec worker) {
    this.worker = worker;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    JindoRuntimeSpec jindoRuntimeSpec = (JindoRuntimeSpec) o;
    return Objects.equals(this.cleanCachePolicy, jindoRuntimeSpec.cleanCachePolicy) &&
        Objects.equals(this.fuse, jindoRuntimeSpec.fuse) &&
        Objects.equals(this.hadoopConfig, jindoRuntimeSpec.hadoopConfig) &&
        Objects.equals(this.jindoVersion, jindoRuntimeSpec.jindoVersion) &&
        Objects.equals(this.labels, jindoRuntimeSpec.labels) &&
        Objects.equals(this.logConfig, jindoRuntimeSpec.logConfig) &&
        Objects.equals(this.master, jindoRuntimeSpec.master) &&
        Objects.equals(this.networkmode, jindoRuntimeSpec.networkmode) &&
        Objects.equals(this.podMetadata, jindoRuntimeSpec.podMetadata) &&
        Objects.equals(this.properties, jindoRuntimeSpec.properties) &&
        Objects.equals(this.replicas, jindoRuntimeSpec.replicas) &&
        Objects.equals(this.runAs, jindoRuntimeSpec.runAs) &&
        Objects.equals(this.secret, jindoRuntimeSpec.secret) &&
        Objects.equals(this.tieredstore, jindoRuntimeSpec.tieredstore) &&
        Objects.equals(this.user, jindoRuntimeSpec.user) &&
        Objects.equals(this.volumes, jindoRuntimeSpec.volumes) &&
        Objects.equals(this.worker, jindoRuntimeSpec.worker);
  }

  @Override
  public int hashCode() {
    return Objects.hash(cleanCachePolicy, fuse, hadoopConfig, jindoVersion, labels, logConfig, master, networkmode, podMetadata, properties, replicas, runAs, secret, tieredstore, user, volumes, worker);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class JindoRuntimeSpec {\n");
    sb.append("    cleanCachePolicy: ").append(toIndentedString(cleanCachePolicy)).append("\n");
    sb.append("    fuse: ").append(toIndentedString(fuse)).append("\n");
    sb.append("    hadoopConfig: ").append(toIndentedString(hadoopConfig)).append("\n");
    sb.append("    jindoVersion: ").append(toIndentedString(jindoVersion)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    logConfig: ").append(toIndentedString(logConfig)).append("\n");
    sb.append("    master: ").append(toIndentedString(master)).append("\n");
    sb.append("    networkmode: ").append(toIndentedString(networkmode)).append("\n");
    sb.append("    podMetadata: ").append(toIndentedString(podMetadata)).append("\n");
    sb.append("    properties: ").append(toIndentedString(properties)).append("\n");
    sb.append("    replicas: ").append(toIndentedString(replicas)).append("\n");
    sb.append("    runAs: ").append(toIndentedString(runAs)).append("\n");
    sb.append("    secret: ").append(toIndentedString(secret)).append("\n");
    sb.append("    tieredstore: ").append(toIndentedString(tieredstore)).append("\n");
    sb.append("    user: ").append(toIndentedString(user)).append("\n");
    sb.append("    volumes: ").append(toIndentedString(volumes)).append("\n");
    sb.append("    worker: ").append(toIndentedString(worker)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

